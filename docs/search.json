[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EAE1106 - M√©todos Computacionais para Economia",
    "section": "",
    "text": "Sobre este material\nEste website re√∫ne o material did√°tico da disciplina EAE1106 ‚Äî M√©todos Computacionais para Economia, ministrada no primeiro semestre de 2026 para as turmas do per√≠odo noturno no Departamento de Economia da Universidade de S√£o Paulo (USP).\nO conte√∫do foi baseado nas notas de aulas e materiais desenvolvidos pelos professores Danilo Souza e Claudio Lucinda e est√° em constante atualiza√ß√£o. Expresso meu especial agradecimento ao Prof.¬†Danilo por compartilhar suas notas de aula e pelos valiosos feedbacks durante a prepara√ß√£o deste material.\nDica: Recomendo fortemente a consulta ao livro digital preparado pelo Prof.¬†Danilo Souza e utilizado nas turmas do per√≠odo diurno neste semestre.\nSugest√µes de melhorias s√£o sempre bem-vindas, seja por meio de issues no GitHub ou pelo e-mail: arthur.viaro@gmail.com",
    "crumbs": [
      "Sobre este material"
    ]
  },
  {
    "objectID": "index.html#como-usar",
    "href": "index.html#como-usar",
    "title": "EAE1106 - M√©todos Computacionais para Economia",
    "section": "Como usar",
    "text": "Como usar\nEste material foi concebido como um livro digital interativo para apoiar as aulas presenciais e servir como refer√™ncia permanente. Mais do que um texto est√°tico, ele √© um ambiente de experimenta√ß√£o. Ler c√≥digo raramente √© suficiente para desenvolver flu√™ncia. A compreens√£o efetiva dos conceitos depende da experimenta√ß√£o ativa. Por isso, encorajamos voc√™ a rodar os exemplos em seu pr√≥prio ambiente, modificando comandos e testando varia√ß√µes.\nEmbora os cap√≠tulos sigam a sequ√™ncia l√≥gica da disciplina, o material permite uma consulta flex√≠vel e n√£o linear. Cada se√ß√£o √© composta por tr√™s elementos fundamentais:\n\nExemplos pr√°ticos dos conceitos te√≥ricos.\nObserva√ß√µes sobre boas pr√°ticas, detalhes t√©cnicos e ‚Äúarmadilhas‚Äù comuns.\nExerc√≠cios para consolidar o aprendizado.\n\nEste material n√£o substitui a presen√ßa em sala de aula. Ao final do semestre, espera-se que voc√™ tenha autonomia para utilizar a programa√ß√£o como uma ferramenta poderosa para organizar dados, explorar informa√ß√µes e fundamentar an√°lises emp√≠ricas em Economia.\n\n\nArthur Viaro  Prof.¬†Assistente em Economia  FEA-USP, Fevereiro 2026",
    "crumbs": [
      "Sobre este material"
    ]
  },
  {
    "objectID": "prefacio.html",
    "href": "prefacio.html",
    "title": "Pref√°cio",
    "section": "",
    "text": "Este material foi desenvolvido como apoio did√°tico para a disciplina EAE1106 ‚Äì M√©todos Computacionais para Economia, ministrada pelo Departamento de Economia da Universidade de S√£o Paulo. A disciplina tem por objetivo oferecer aos estudantes uma introdu√ß√£o sistem√°tica √† l√≥gica de programa√ß√£o e √†s t√©cnicas de an√°lise de dados utilizando linguagens de programa√ß√£o, com √™nfase em Python e uma breve introdu√ß√£o a R ao final do semestre.\nO curso parte da motiva√ß√£o de que grande parte das perguntas contempor√¢neas em economia ‚Äì desde a explora√ß√£o de grandes bases de dados at√© a implementa√ß√£o de simula√ß√µes e modelos num√©ricos ‚Äì exige o uso de ferramentas computacionais para organizar, manipular, visualizar e interpretar dados de forma eficiente. Consequentemente, a capacidade de expressar uma sequ√™ncia de opera√ß√µes de forma reproduz√≠vel e automatizada √© uma compet√™ncia essencial para economistas que desejam conduzir an√°lises emp√≠ricas rigorosas e comunicar resultados de forma clara e estruturada.\nEste material foi concebido com duas orienta√ß√µes principais:\n\nProgress√£o pedag√≥gica gradual. O conte√∫do inicia por fundamentos de l√≥gica de programa√ß√£o, tipos de dados e objetos dentro da linguagem, controle de fluxo e fun√ß√µes, e evolui para t√≥picos aplicados de manipula√ß√£o de dados, √°lgebra linear, visualiza√ß√£o e an√°lise integrada de dados. A estrutura dos cap√≠tulos foi planejada para acompanhar as etapas do racioc√≠nio computacional e da an√°lise emp√≠rica.\nAplica√ß√£o orientada a problemas econ√¥micos. Sempre que poss√≠vel, os exemplos e exerc√≠cios s√£o contextualizados em quest√µes emp√≠ricas de interesse econ√¥mico, tais como manipula√ß√£o e an√°lise de bases de dados administrativas, c√°lculo de estat√≠sticas descritivas e visualiza√ß√£o explorat√≥ria. Isso visa refor√ßar a conex√£o entre m√©todos computacionais e aplica√ß√µes reais em pesquisa econ√¥mica.\n\nAl√©m dessas orienta√ß√µes gerais, o curso est√° organizado em tr√™s grandes blocos de conte√∫do, que estruturam tanto as aulas quanto este material:\n\nAlfabetiza√ß√£o computacional e l√≥gica b√°sica, que introduz os conceitos fundamentais de computa√ß√£o, a intera√ß√£o entre linguagens de programa√ß√£o e modelos de intelig√™ncia artificial, tipos primitivos e objetos b√°sicos dentro do Python, al√©m de como implementar controle de fluxo, itera√ß√£o, fun√ß√µes personalizadas dentro da linguagem.\nComputa√ß√£o num√©rica, an√°lise de dados e visualiza√ß√£o, com foco em estruturas matriciais e √°lgebra linear atrav√©s do uso do pacote NumPy, manipula√ß√£o eficiente de dados em dataframes com Pandas, constru√ß√£o e personaliza√ß√£o de gr√°ficos, e princ√≠pios b√°sicos de visualiza√ß√£o de dados, culminando em uma an√°lise emp√≠rica integrada que enfatiza organiza√ß√£o de projetos, reprodutibilidade e constru√ß√£o de pipelines completos.\nTemas complementares, que incluem uma pequena introdu√ß√£o a t√≥picos mais avan√ßados, como a programa√ß√£o orientada a objetos, e uma breve introdu√ß√£o √† linguagem R, com o objetivo de familiarizar o estudante com outro ecossistema amplamente utilizado em an√°lise emp√≠rica e principal linguagem utilizada ao longo da sequ√™ncia de cursos obrigat√≥rios de Econometria.\n\nDe forma geral, o conte√∫do foi organizado como um livro digital interativo, com exemplos de c√≥digo e sa√≠das esperadas, visualiza√ß√µes e anota√ß√µes integradas. O uso de linguagens de programa√ß√£o neste formato permite que o leitor aprenda de forma construtiva e ativa, facilitando a compreens√£o da sintaxe, l√≥gica e aprendendo a avaliar erros e como corrig√≠-los. Espero que este material seja √∫til tanto para estudantes que se aproximam pela primeira vez da programa√ß√£o aplicada √† economia quanto para aqueles que desejam refor√ßar e aplicar os conceitos em trabalhos emp√≠ricos e projetos de pesquisa.",
    "crumbs": [
      "Pref√°cio"
    ]
  },
  {
    "objectID": "ch-01.html",
    "href": "ch-01.html",
    "title": "Fundamentos de Computa√ß√£o",
    "section": "",
    "text": "Esta parte inicial do curso √© dedicada √† alfabetiza√ß√£o computacional e √† constru√ß√£o dos fundamentos da l√≥gica de programa√ß√£o. O objetivo √© desenvolver, de forma gradual, a capacidade de compreender, escrever e interpretar c√≥digo, preparando o terreno para aplica√ß√µes emp√≠ricas mais avan√ßadas nas etapas seguintes do curso.\nNesta etapa, trabalharemos com os conceitos b√°sicos da linguagem Python, sem assumir conhecimento pr√©vio em programa√ß√£o. O foco est√° menos em bibliotecas especializadas e mais na compreens√£o dos elementos fundamentais que estruturam qualquer programa: sintaxe, tipos de dados e objetos, opera√ß√µes, controle de fluxo, fun√ß√µes e boas pr√°ticas de c√≥digo. Listo abaixo alguns dos principais conceitos trabalhados nos cap√≠tulos que comp√µem esta parte do curso:\n\nCap√≠tulo 1 ‚Äì Fundamentos de computa√ß√£o. Introduz no√ß√µes b√°sicas sobre como computadores funcionam, o que significa programar e quais as caracter√≠sticas que diferenciam as v√°rias linguagens de programa√ß√£o dispon√≠veis. O objetivo √© construir uma base conceitual m√≠nima para entender o que acontece ‚Äúpor tr√°s‚Äù do c√≥digo.\nCap√≠tulo 2 ‚Äì Primeiros passos no Python. Apresenta o Python como linguagem de programa√ß√£o, discutindo sua sintaxe b√°sica, a execu√ß√£o de comandos simples e a intera√ß√£o com o ambiente de desenvolvimento. Este cap√≠tulo marca o primeiro contato pr√°tico com a escrita e execu√ß√£o de c√≥digo.\nCap√≠tulo 3 ‚Äì Programa√ß√£o e Intelig√™ncia Artificial. Discute, de forma introdut√≥ria, a rela√ß√£o entre programa√ß√£o, automa√ß√£o e modelos de intelig√™ncia artificial. O objetivo n√£o √© aprofundar t√©cnicas de IA, mas contextualizar o uso de algoritmos, modelos e linguagens de programa√ß√£o em aplica√ß√µes modernas, incluindo suas limita√ß√µes e implica√ß√µes.\nCap√≠tulo 4 ‚Äì Tipos primitivos e objetos b√°sicos. Introduz os principais tipos de dados do Python ‚Äì como n√∫meros, strings e booleanos ‚Äì e os objetos b√°sicos utilizados para armazenar e manipular os diferentes tipos de informa√ß√£o. Este cap√≠tulo estabelece a base para compreender como a informa√ß√£o √© representada em programas.\nCap√≠tulo 5 ‚Äì Controle de fluxo e itera√ß√£o. Apresenta estruturas fundamentais para controlar a execu√ß√£o de um programa, como condicionais e la√ßos de repeti√ß√£o (loops, em ingl√™s). S√£o discutidas formas de automatizar tarefas repetitivas e de implementar l√≥gica condicional, elementos centrais em qualquer aplica√ß√£o computacional.\nCap√≠tulo 6 ‚Äì Fun√ß√µes. Este cap√≠tulo tem por objetivo desenvolver o conceito de fun√ß√µes como forma de organizar c√≥digo, evitar repeti√ß√£o e tornar programas mais leg√≠veis e reutiliz√°veis. Discute defini√ß√£o, uso e boas pr√°ticas na cria√ß√£o de fun√ß√µes, preparando o aluno para estruturar programas mais complexos.\n\nJuntos, esses seis cap√≠tulos estabelecem as bases conceituais e pr√°ticas da programa√ß√£o, permitindo que o aluno desenvolva familiaridade com o racioc√≠nio computacional e com a linguagem Python. Ao final desta parte do curso, mais do que memorizar comandos espec√≠ficos, espera-se que o estudante seja capaz de ler, compreender e construir pequenos programas, criando uma base s√≥lida para o uso de ferramentas computacionais em an√°lise de dados e aplica√ß√µes emp√≠ricas em economia nas etapas seguintes da disciplina.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o"
    ]
  },
  {
    "objectID": "fundamentos.html",
    "href": "fundamentos.html",
    "title": "1¬† Como um computador funciona",
    "section": "",
    "text": "1.1 Introdu√ß√£o\nAntes de escrever qualquer linha de c√≥digo, √© importante entender o ambiente no qual a programa√ß√£o acontece. Programar n√£o √© apenas aprender uma linguagem espec√≠fica, mas tamb√©m compreender como o computador organiza arquivos, executa comandos e interage com o sistema operacional. Muitos dos erros e dificuldades enfrentados por iniciantes em programa√ß√£o n√£o est√£o relacionados √† l√≥gica do c√≥digo em si, mas ao uso do computador como ferramenta de trabalho: navegar por diret√≥rios, localizar arquivos, executar programas e interpretar mensagens do sistema. Esses aspectos s√£o frequentemente tratados como triviais, mas s√£o fundamentais para o uso eficiente de qualquer linguagem de programa√ß√£o.\nEste cap√≠tulo introduz conceitos fundamentais sobre o funcionamento de computadores, a representa√ß√£o de informa√ß√µes em bits e bytes, a organiza√ß√£o de arquivos e a forma como interagimos com o sistema operacional via terminal. Esses elementos servir√£o como infraestrutura conceitual para todo o restante do curso. O foco aqui n√£o √© aprofundar detalhes t√©cnicos de hardware ou sistemas operacionais, mas fornecer uma vis√£o pr√°tica e funcional do ambiente computacional que ser√° utilizado ao longo da disciplina.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#introdu√ß√£o",
    "href": "fundamentos.html#introdu√ß√£o",
    "title": "1¬† Como um computador funciona",
    "section": "",
    "text": "Figura¬†1.1: Setup usual de um computador pessoal no come√ßo dos anos 2000. Fonte: Wikimedia Commons\n\n\n\n\n1.1.1 Pr√©-requisitos\nNeste cap√≠tulo introdut√≥rio n√£o utilizaremos nenhum programa ou linguagem. Ele foi escrito para que mesmo o aluno sem nenhum tipo de conhecimento em computa√ß√£o e com o m√≠nimo de conhecimento a respeito de opera√ß√µes matem√°tica elementares tenha capacidade de acompanhar. Basta curiosidade!",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#como-um-computador-funciona",
    "href": "fundamentos.html#como-um-computador-funciona",
    "title": "1¬† Como um computador funciona",
    "section": "1.2 Como um computador funciona",
    "text": "1.2 Como um computador funciona\nUm computador realiza duas coisas e apenas duas coisas: faz opera√ß√µes e guarda de forma eficiente o resultado dessas opera√ß√µes. No entanto, ao fazer essas duas coisas de forma extremamente eficiente essa m√°quina chamada computador nos permite receber, armazenar, processar e transmitir informa√ß√µes. Em ess√™ncia, o computador nos serve ao prop√≥sito de resolu√ß√£o de problemas. Isso significa que, atrav√©s de uma linguagem formal (especificamente opera√ß√µes de computa√ß√£o), podemos formular problemas e programar meios de resolver de forma automatizada tais problemas. No fim das contas, programar √© o ato de criar programas, isto √©, estabelecer uma sequ√™ncia de instru√ß√µes em linguagem formal que especifica como executar uma determinada opera√ß√£o no computador.\nMas antes de avan√ßar na ideia de programa e algoritmos, quais s√£o as caracter√≠sticas de um computador como o conhecemos?\n\n1.2.1 Sistema computacional\nUm sistema computacional √© resultado da integra√ß√£o de componentes atuando como uma entidade, com o prop√≥sito de processar dados, isto √©, realizar algum tipo de opera√ß√£o l√≥gica envolvendo os dados, de modo a produzir diferentes n√≠veis de informa√ß√µes. Tais sistemas s√£o compostos por 3 principais elementos: hardware, software e o componente humano. O hardware inclui os componentes f√≠sicos enquanto o software √© o conjunto de instru√ß√µes que diz ao hardware o que fazer. No entanto, o software n√£o elabora e decide sozinho o tipo de instru√ß√£o a ser enviada ao hardware, √© s√≥ atrav√©s do componente humano que as instru√ß√µes e objetivos s√£o definidos.\n\nHardware: componente f√≠sico de um sistema de computa√ß√£o, isto √©, todos os equipamentos utilizados pelo usu√°rio nas a√ß√µes de entrada, processamento, armazenamento e sa√≠da de dados. Exemplos:\n\nTeclado, mouse, impressora\nUnidade central de processamento (CPU, em ingl√™s) ou processador\nPlaca m√£e\nPlaca de v√≠deo (GPU)\nMem√≥ria RAM\nDisco r√≠gido de armazenamento\n\nSoftware: componente l√≥gico de um sistema de computa√ß√£o, isto √©, s√©ries de instru√ß√µes que fazem o computador funcionar. S√£o os famosos programas de computador, que podem ser (i) propriet√°rios e utiliz√°veis a partir da compra de uma licen√ßa ou (ii) gratuitos. Exemplos:\n\nEditores de texto (e.g., Microsoft Word)\nEditor de planilhas (e.g., Microsoft Excel)\nBrowsers para navega√ß√£o na internet (e.g., Safari e Google Chrome)\n\nComponente humano: as pessoas, que utilizam o computador basicamente como ferramenta para atingir determinado fim, para resolver problemas. Sem a a√ß√£o de um indiv√≠duo o sistema computacional n√£o funciona, j√° que (ainda) depende das instru√ß√µes e direcionamento humano para definir o que o software deve fazer e como deve interagir com o hardware.\n\n\n\n1.2.2 Arquitetura de um computador\nA arquitetura de um computador define como os componentes est√£o interconectados e como eles colaboram para executar tarefas. Os computadores, como os conhecemos hoje, s√£o estruturados em cima da l√≥gica proposta inicialmente por John Von Neumann, matem√°tico h√∫ngaro que viveu durante a primeira metade do s√©culo XX e que contribuiu imensamente em v√°rias √°reas das ci√™ncias. Embora tenhamos hoje uma complexidade maior nos elementos que comp√µe a arquitetura de um computador, a estrutura b√°sica por tr√°s dos computadores mais modernos continua sendo aquela proposta por Von Neumann. Essa arquitetura pode ser representado pelo diagrama abaixo:\n\n\n\n\n\n\nFigura¬†1.2: Diagrama que representa o funcionamento da arquitetura Von-Neumann\n\n\n\nEssencialmente, o hadware que comp√µe as partes da arquitetura de um computador podem ser dividas em 3 partes:\n\nDispositivos de entrada e sa√≠da: √© atrav√©s deles que o usu√°rio dialoga com a m√°quina. Atrav√©s do teclado e mouse, por exemplo, o usu√°rio fornece informa√ß√µes ao computador a partir das quais processos ser√£o realizados e seus resultados ser√£o percebidos pelos dispositivos de sa√≠da (monitor e impressora, por exemplo).\nProcessador ou CPU: √© o c√©rebro do sistema computacional, √© nele que ser√£o executados c√°lculos e instru√ß√µes l√≥gicas dos usu√°rios.\nMem√≥ria: aqui s√£o armazenados temporariamente os resultados dos c√°lculos, dados e instru√ß√µes. Esse armazenamento na mem√≥ria, por√©m, n√£o √© feito de forma permanente, ele serve apenas como suporte ao processador. √â como se o processador utilizasse a mem√≥ria de caderno de anota√ß√µes, retomando o resultado dos c√°lculos j√° realizados sempre que necess√°rio.\n\n\n\n\n\n\n\nImportanteImportante\n\n\n\nN√£o confunda mem√≥ria com o que chamamos de armazenamento. A mem√≥ria do computador, normalmente na forma da chamada mem√≥ria RAM (sigla para Random Access Memory), √© respons√°vel por armazenar temporariamente os dados de dos programas que est√£o em uso, permitindo acesso r√°pido pelo processador. √â tamb√©m chamada de mem√≥ria vol√°til: todo o seu conte√∫do √© perdido quando o computador √© desligado.\nJ√° as informa√ß√µes armazenadas no disco r√≠gido (Hard Disk Drive, HDD) ou na unidade de estado s√≥lido (Solid-State Drive, SSD) n√£o s√£o perdidas quando o computador √© desligado. Esses dispositivos mant√™m os dados armazenados de forma persistente, funcionando como a ‚Äúmem√≥ria de longo prazo‚Äù do computador. Por isso, esse tipo de armazenamento √© chamado de mem√≥ria n√£o vol√°til.\nFazendo uma analogia com o funcionamento do nosso c√©rebro, a mem√≥ria RAM armazena informa√ß√µes de curto prazo, como o que voc√™ almo√ßou hoje. Esse tipo de informa√ß√£o √© importante ao longo do dia, por exemplo para saber se voc√™ j√° se alimentou bem ou se ainda est√° longe da sua meta di√°ria de prote√≠na, mas costuma ser esquecida depois que voc√™ dorme.\nJ√° o HDD ou SSD armazena informa√ß√µes de longo prazo, como mem√≥rias da inf√¢ncia ou experi√™ncias passadas. Essas informa√ß√µes n√£o s√£o utilizadas constantemente no dia a dia, mas permanecem dispon√≠veis e podem ser √∫teis em conversas com amigos ou como aprendizado acumulado, por exemplo na hora de decidir como cuidar dos seus filhos quando chegar a hora.\n\n\n\n\n1.2.3 Bits e bytes\nPara entender como um computador armazena e processa informa√ß√µes, √© necess√°rio compreender o conceito de sistema bin√°rio ou sistema de base 21. Diferentemente do sistema decimal, que utilizamos no dia a dia e possui dez d√≠gitos (de 0 a 9), os computadores operam utilizando apenas dois estados poss√≠veis: 0 e 1. Pense nisso como um interruptor, em que 1 representa o estado ‚Äúligado‚Äù e 0 o estado ‚Äúdesligado‚Äù. Os processadores atuais de um computador s√£o resultado da jun√ß√£o de bilh√µes desses min√∫sculos ‚Äúinterruptores‚Äù, tamb√©m chamados de transistores.\nEsses dois estados, 0 ou 1, tamb√©m s√£o chamados de bits (do ingl√™s binary digits). Um bit representa a menor unidade de informa√ß√£o que um computador pode armazenar. Qualquer informa√ß√£o processada por um computador ‚Äì n√∫meros, textos, imagens ou v√≠deos ‚Äì √©, em √∫ltima inst√¢ncia, representada como uma sequ√™ncia de bits.\nComo trabalhar com bits individualmente seria pouco pr√°tico, eles s√£o agrupados em unidades maiores chamadas de bytes. Um byte √© composto por 8 bits e permite representar um conjunto maior de valores. Um byte pode representar 256 (\\(2^8 = 256\\)) combina√ß√µes diferentes, o que √© suficiente para representar todas as letras mai√∫sculas e min√∫sculas, n√∫meros e s√≠mbolos b√°sicos do alfabeto ingl√™s. N√£o √† toa, o byte se tornou a unidade padr√£o de medida quando o assunto √© capacidade de armazenar informa√ß√£o em um computador. A Tabela Tabela¬†1.1 mostra como converter alguns n√∫meros do sistema decimal para o sistema bin√°rio de 8 bits, em que cada d√≠gito dib√°rio indica a presen√ßa ou aus√™ncia de uma pot√™ncia de 2.\n\n\n\nTabela¬†1.1: Representa√ß√£o de n√∫meros decimais no sistema bin√°rio e detalhamento do c√°lculo para convers√£o.\n\n\n\n\n\n\n\n\n\n\nN√∫mero decimal\nN√∫mero bin√°rio\nC√°lculo para convers√£o\n\n\n\n\n0\n00000000\n\\(0\\cdot 2^7 + 0\\cdot 2^6 + 0\\cdot 2^5 + 0\\cdot 2^4 + 0\\cdot 2^3 + 0\\cdot 2^2 + 0\\cdot 2^1 + 0\\cdot 2^0 = 0\\)\n\n\n1\n00000001\n\\(0\\cdot 2^7 + 0\\cdot 2^6 + 0\\cdot 2^5 + 0\\cdot 2^4 + 0\\cdot 2^3 + 0\\cdot 2^2 + 0\\cdot 2^1 + 1\\cdot 2^0 = 1\\)\n\n\n5\n00000101\n\\(0\\cdot 2^7 + 0\\cdot 2^6 + 0\\cdot 2^5 + 0\\cdot 2^4 + 0\\cdot 2^3 + 1\\cdot 2^2 + 0\\cdot 2^1 + 1\\cdot 2^0 = 5\\)\n\n\n48\n00110000\n\\(0\\cdot 2^7 + 0\\cdot 2^6 + 1\\cdot 2^5 + 1\\cdot 2^4 + 0\\cdot 2^3 + 0\\cdot 2^2 + 0\\cdot 2^1 + 0\\cdot 2^0 = 48\\)\n\n\n137\n10001001\n\\(1\\cdot 2^7 + 0\\cdot 2^6 + 0\\cdot 2^5 + 0\\cdot 2^4 + 1\\cdot 2^3 + 0\\cdot 2^2 + 0\\cdot 2^1 + 1\\cdot 2^0 = 137\\)\n\n\n255\n11111111\n\\(1\\cdot 2^7 + 1\\cdot 2^6 + 1\\cdot 2^5 + 1\\cdot 2^4 + 1\\cdot 2^3 + 1\\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0 = 255\\)\n\n\n\n\n\n\nA partir dos bytes, surgem unidades maiores, amplamente utilizadas para medir o tamanho de arquivos, a quantidade de mem√≥ria e a capacidade de armazenamento: quilobytes, megabytes, gigabytes, terabytes e petabytes. Essas unidades indicam, essencialmente, quantos bytes s√£o necess√°rios para representar uma determinada quantidade de informa√ß√£o.\n\nKilobyte (KB): \\(1{,}024\\) (ou \\(2^{10}\\)) bytes.\nMegabyte (MB): \\(1{,}048{,}576\\) (ou \\(2^{20}\\)) bytes.\nGigabyte (GB): \\(1{,}073{,}741{,}824\\) (ou \\(2^{30}\\)) bytes.\nTerabyte (TB): \\(1{,}099{,}511{,}627{,}776\\) (ou \\(2^{40}\\)) bytes.\nPetabyte (PB): \\(1{,}125{,}899{,}906{,}842{,}624\\) (ou \\(2^{50}\\)) bytes.\nExabyte, Zettabyte, Yottabyte‚Ä¶\n\nCompreender bits e bytes √© fundamental para entender por que arquivos t√™m tamanhos diferentes, por que algumas opera√ß√µes exigem mais mem√≥ria do que outras e por que certas tarefas computacionais s√£o mais custosas do ponto de vista de processamento. Esses agrupamentos de bits (bytes) s√£o as unidades b√°sicas que a mem√≥ria e o armazenamento usam para guardar informa√ß√£o. A pr√≥xima se√ß√£o explica o papel desses componentes e como eles impactam o desempenho pr√°tico.\n\n\n1.2.4 ASCII\nAssim como os n√∫meros s√£o representados por padr√µes bin√°rios de zeros e uns, os caracteres de texto ‚Äî letras, n√∫meros, sinais de pontua√ß√£o e s√≠mbolos ‚Äî tamb√©m s√£o codificados como sequ√™ncias de bits. Como os mesmos padr√µes bin√°rios poderiam ser interpretados de maneiras distintas, tornou-se necess√°rio estabelecer uma conven√ß√£o padronizada.\nUma das primeiras e mais importantes conven√ß√µes foi o ASCII (American Standard Code for Information Interchange). O ASCII associa um n√∫mero inteiro espec√≠fico a cada caractere, permitindo que computadores representem texto de forma consistente. Por exemplo, a letra A est√° associada ao n√∫mero decimal 65, que em bin√°rio √© representado por 01000001.\nSuponha que voc√™ recebesse uma sequ√™ncia bin√°ria correspondente aos n√∫meros decimais 72, 73 e 33. Ao convert√™-los segundo a tabela ASCII, obter√≠amos os caracteres H, I e !, formando a express√£o HI!. √â gra√ßas a padr√µes como o ASCII que diferentes computadores ‚Äúconcordam‚Äù sobre qual n√∫mero representa qual caractere.\nA tabela a seguir apresenta um mapa dos valores ASCII:\n\n\n\nTabela¬†1.2: Tabela ASCII.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\nNUL\n16\nDLE\n32\nSP\n48\n0\n64\n@\n80\nP\n96\n`\n112\np\n\n\n1\nSOH\n17\nDC1\n33\n!\n49\n1\n65\nA\n81\nQ\n97\na\n113\nq\n\n\n2\nSTX\n18\nDC2\n34\n‚Äù\n50\n2\n66\nB\n82\nR\n98\nb\n114\nr\n\n\n3\nETX\n19\nDC3\n35\n#\n51\n3\n67\nC\n83\nS\n99\nc\n115\ns\n\n\n4\nEOT\n20\nDC4\n36\n$\n52\n4\n68\nD\n84\nT\n100\nd\n116\nt\n\n\n5\nENQ\n21\nNAK\n37\n%\n53\n5\n69\nE\n85\nU\n101\ne\n117\nu\n\n\n6\nACK\n22\nSYN\n38\n&\n54\n6\n70\nF\n86\nV\n102\nf\n118\nv\n\n\n7\nBEL\n23\nETB\n39\n‚Äô\n55\n7\n71\nG\n87\nW\n103\ng\n119\nw\n\n\n8\nBS\n24\nCAN\n40\n(\n56\n8\n72\nH\n88\nX\n104\nh\n120\nx\n\n\n9\nHT\n25\nEM\n41\n)\n57\n9\n73\nI\n89\nY\n105\ni\n121\ny\n\n\n10\nLF\n26\nSUB\n42\n*\n58\n:\n74\nJ\n90\nZ\n106\nj\n122\nz\n\n\n11\nVT\n27\nESC\n43\n+\n59\n;\n75\nK\n91\n[\n107\nk\n123\n{\n\n\n12\nFF\n28\nFS\n44\n,\n60\n&lt;\n76\nL\n92\n\\\n108\nl\n124\n|\n\n\n13\nCR\n29\nGS\n45\n-\n61\n=\n77\nM\n93\n]\n109\nm\n125\n}\n\n\n14\nSO\n30\nRS\n46\n.\n62\n&gt;\n78\nN\n94\n^\n110\nn\n126\n~\n\n\n15\nSI\n31\nUS\n47\n/\n63\n?\n79\nO\n95\n_\n111\no\n127\nDEL\n\n\n\n\n\n\nNote que cada caractere ASCII ocupa 1 byte (8 bits). Com 8 bits, √© poss√≠vel representar at√© 256 valores distintos (de 0 a 255). No entanto, o ASCII padr√£o utiliza apenas os valores de 0 a 127, totalizando 128 caracteres. Os c√≥digos de 0 a 31 e o 127 correspondem a caracteres de controle (como quebra de linha e tabula√ß√£o), enquanto os valores de 32 a 126 representam caracteres imprim√≠veis.\n\n\n1.2.5 UNICODE\nCom a expans√£o da comunica√ß√£o digital em escala global, o limite de 128 caracteres do ASCII original - e mesmo as extens√µes de 256 caracteres - tornou-se insuficiente. Era necess√°rio um padr√£o capaz de representar diferentes alfabetos, sistemas de escrita, s√≠mbolos matem√°ticos, caracteres t√©cnicos e, mais recentemente, emojis.\nüòÄ üòÉ üòÑ üòÅ üòÜ üòÖ üòÇ üôÇ üôÉ üòâ üòä üòá üòç üòò üòó üòô üòö üòã üòõ üòú üòù ü§ë ü§ì üòé ü§ó üòè üò∂ üòê üòë üòí üôÑ üò¨ üòï ‚òπÔ∏è üòü üòÆ üòØ üò≤ üò≥ üò¶ üòß üò®\nO Unicode surgiu com esse objetivo: criar um sistema universal de codifica√ß√£o capaz de representar praticamente todos os sistemas de escrita utilizados pela humanidade, al√©m de s√≠mbolos e elementos gr√°ficos. Diferentemente do ASCII, o Unicode n√£o est√° limitado a 8 bits. Ele define um conjunto muito mais amplo de c√≥digos (chamados code points), que podem ser representados por diferentes esquemas de codifica√ß√£o, como UTF-8, UTF-16 e UTF-32. O UTF-8, por exemplo, √© hoje o padr√£o dominante na internet.\nEmbora o c√≥digo num√©rico associado a cada caractere seja universal, sua apar√™ncia visual pode variar entre sistemas e fabricantes. Assim, um mesmo emoji pode ter pequenas diferen√ßas de design em dispositivos da Apple, Google ou Microsoft. O padr√£o Unicode continua em expans√£o, incorporando novos caracteres e emojis para refletir transforma√ß√µes culturais, lingu√≠sticas e tecnol√≥gicas.2\n\n\n1.2.6 RGB\nOs mesmos zeros e uns que representam letras e n√∫meros tamb√©m podem representar cores. No sistema RGB (Red, Green, Blue), cada cor √© definida pela combina√ß√£o das intensidades de vermelho, verde e azul. Cada uma dessas tr√™s intensidades √© representada por um n√∫mero entre 0 e 255 ‚Äî ou seja, 8 bits para cada canal de cor. Assim, uma cor no sistema RGB utiliza 3 bytes (24 bits no total):\n\nPor exemplo, a sequ√™ncia num√©rica (72, 73, 33) ‚Äî que no contexto ASCII corresponde a HI! ‚Äî poderia, em um contexto de imagem, ser interpretada como uma cor espec√≠fica. Essa combina√ß√£o resulta em um tom escuro amarelado-esverdeado:\n = \nCada conjunto de tr√™s valores RGB forma um pixel (um ponto de cor). Uma imagem digital nada mais √© do que uma grande matriz de pixels, isto √©, uma matriz de n√∫meros. Quanto maior o n√∫mero de pixels, maior a resolu√ß√£o da imagem. Da mesma forma, sons e v√≠deos tamb√©m s√£o representados por sequ√™ncias num√©ricas. No caso do √°udio, os n√∫meros codificam varia√ß√µes de amplitude ao longo do tempo; no caso do v√≠deo, combinam-se sequ√™ncias de imagens (frames) com informa√ß√£o sonora. Em √∫ltima inst√¢ncia, todo conte√∫do digital ‚Äî texto, imagem, som ou v√≠deo ‚Äî √© armazenado como padr√µes de zeros e uns.\n\n\n1.2.7 Processamento, mem√≥ria e armazenamento na pr√°tica\nPodemos entender o funcionamento de um computador como um fluxo cont√≠nuo de leitura, processamento e armazenamento de bits. Quando observamos as especifica√ß√µes de um computador pessoal, √© comum encontrar informa√ß√µes como n√∫mero de n√∫cleos do processador (cores), frequ√™ncia do processador em gigahertz (GHz), quantidade de mem√≥ria RAM e capacidade de armazenamento em disco. Esses n√∫meros descrevem, essencialmente, a velocidade e a escala com que o computador consegue manipular grandes volumes de informa√ß√£o bin√°ria em cada etapa desse fluxo cont√≠nuo.\nProcessamento refere-se √† execu√ß√£o de instru√ß√µes sobre dados representados em bits. O processador √© o componente respons√°vel por realizar opera√ß√µes elementares que, em √∫ltima inst√¢ncia, s√£o opera√ß√µes l√≥gicas sobre sequ√™ncias de zeros e uns. A frequ√™ncia do processador indica aproximadamente quantos ciclos de processamento podem ser realizados por segundo. Frequ√™ncias mais altas permitem que mais instru√ß√µes sejam executadas em menos tempo, embora o desempenho final dependa tamb√©m da organiza√ß√£o do c√≥digo, do tipo de tarefa e do acesso √† mem√≥ria. Al√©m disso, processadores modernos possuem m√∫ltiplos cores ou n√∫cleos. O uso de m√∫ltiplos n√∫cleos permite paralelismo, isto √©, a execu√ß√£o simult√¢nea de diferentes partes de uma tarefa, de forma an√°loga a dividir um trabalho entre v√°rias pessoas para conclu√≠-lo mais rapidamente.\nMem√≥ria (RAM) √© o espa√ßo onde os dados e instru√ß√µes ficam armazenados temporariamente enquanto est√£o sendo processados. √â na mem√≥ria RAM que o computador mant√©m os bytes que ser√£o acessados repetidamente pelo processador. Quanto maior a quantidade de RAM dispon√≠vel, maior √© o volume de dados que pode ser mantido ‚Äúem uso‚Äù ao mesmo tempo. Quando a RAM √© insuficiente, o computador passa a usar o disco como apoio, o que reduz drasticamente o desempenho.\nArmazenamento, por sua vez, diz respeito ao local onde os dados s√£o guardados de forma permanente. HDDs e SSDs armazenam grandes volumes de bytes mesmo quando o computador est√° desligado. A diferen√ßa principal √© que SSDs permitem acesso muito mais r√°pido aos dados, reduzindo o tempo necess√°rio para carregar programas, abrir arquivos e transferir grandes conjuntos de dados para a mem√≥ria.\nVistos em conjunto, processamento, mem√≥ria e armazenamento formam um sistema integrado: dados s√£o lidos do disco, carregados na mem√≥ria, processados pela CPU e, quando necess√°rio, gravados novamente no armazenamento. Para tarefas simples, esse fluxo passa despercebido. Para programa√ß√£o, an√°lise de dados e computa√ß√£o num√©rica compreender essas etapas ajuda a interpretar erros, gargalos de desempenho e limita√ß√µes pr√°ticas do ambiente computacional.\n\n\n\n\n\n\nDicaO que significam as especifica√ß√µes do seu computador?\n\n\n\nConsidere um computador com processador com 16 n√∫cleos e frequ√™ncia de 3.2 GHz, 32 GB de mem√≥ria RAM e 1 TB de SSD. Esses n√∫meros descrevem como ele lida com bits e bytes em diferentes etapas do processamento.\n\n16 n√∫cleos (cores) indicam que o processador pode executar v√°rias tarefas ao mesmo tempo. Em aplica√ß√µes que permitem paralelismo ‚Äì como certas opera√ß√µes num√©ricas ou an√°lises sobre grandes conjuntos de dados ‚Äì isso √© semelhante a dividir o trabalho entre dezesseis pessoas em vez de apenas uma.\n3.2 GHz refere-se √† velocidade com que cada n√∫cleo executa instru√ß√µes elementares. Em termos simples, indica quantos passos o processador consegue dar por segundo ao manipular dados representados em sistema bin√°rio.\n32 GB de RAM significam que at√© esse volume de dados pode permanecer dispon√≠vel para acesso r√°pido enquanto programas est√£o em execu√ß√£o. Bases de dados grandes, matrizes extensas e m√∫ltiplos processos consomem mem√≥ria rapidamente.\n1 TB de SSD indica a capacidade de armazenamento permanente.\n\nEm an√°lise de dados e programa√ß√£o, problemas de desempenho raramente est√£o ligados apenas √† velocidade do processador. Com frequ√™ncia, eles surgem porque os dados s√£o grandes demais para caber na mem√≥ria ou porque opera√ß√µes s√£o realizadas de forma pouco eficiente. Entender essas especifica√ß√µes ajuda a interpretar erros, lentid√£o e limita√ß√µes pr√°ticas do ambiente computacional.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#arquivos-e-diret√≥rios",
    "href": "fundamentos.html#arquivos-e-diret√≥rios",
    "title": "1¬† Como um computador funciona",
    "section": "1.3 Arquivos e diret√≥rios",
    "text": "1.3 Arquivos e diret√≥rios\nMais do que armazenar informa√ß√£o, √© importante entender onde e como a informa√ß√£o √© armazenada. Assim como na vida cotidiana, √© preciso ter organiza√ß√£o no armazenamento para saber como e onde procurar determinada informa√ß√£o no computador. Se voc√™ √© uma pessoa organizada, voc√™ sabe que o iogurte estar√° sempre guardada na geladeira e em algum pote fechado, n√£o √© preciso procurar debaixo do chuveiro em um saco de p√£o.\n\n1.3.1 Estrutura hier√°rquica\nOs diret√≥rios servem justamente para organizar o armazenamento do computador. √â como se voc√™ pudesse separar o seu SSD primeiro em c√¥modos, depois em arm√°rios dentro de cada c√¥modo, em gavetas dentro de cada arm√°rio e assim por diante. Formalmente, um diret√≥rio pode ser entendido como um cont√™iner no qual arquivos e outros diret√≥rios podem estar organizados, formando uma estrutura hier√°rquica. Essa organiza√ß√£o permite localizar, acessar e manipular arquivos de forma sistem√°tica, especialmente em projetos maiores.\nPor exemplo, a organiza√ß√£o de um projeto de an√°lise de dados pode ter a seguinte forma:\nC:\\\n‚îî‚îÄ‚îÄ projeto\\\n    ‚îú‚îÄ‚îÄ data\\\n    ‚îÇ   ‚îî‚îÄ‚îÄ dados.csv\n    ‚îú‚îÄ‚îÄ scripts\\\n    ‚îÇ   ‚îî‚îÄ‚îÄ analise.py\n    ‚îî‚îÄ‚îÄ resultados\\\n        ‚îî‚îÄ‚îÄ figura1.png\nNesse exemplo, projeto √© um diret√≥rio que est√° dentro da parti√ß√£o C e que cont√©m outros diret√≥rios. O arquivo dados.csv, por exemplo, est√° dentro do diret√≥rio data, que √© um diret√≥rio localizado dentro do diret√≥rio projeto. Para acessar esse arquivo dados.csv dentro dessa estrutura hier√°rquica de diret√≥rios utilizamos duas formas principais: o caminho absoluto ou o caminho relativo.\n\nCaminho absoluto: descreve a localiza√ß√£o completa a partir da raiz do sistema de arquivos. Nesse caso, o caminho absoluto seria C:\\projeto\\data\\dados.csv.\nCaminho relativo: descreve a localiza√ß√£o em rela√ß√£o ao diret√≥rio atual. Isso quer dizer que, se estivermos trabalhando em um programa a partir do diret√≥rio projeto, para acessar o arquivo de dados basta descrever o caminho relativo a partir dali: data/dados.csv.\n\n\n\n1.3.2 Extens√µes de arquivos\nPara al√©m do onde, a informa√ß√£o em si pode ser armazenada de v√°rias formas. Voc√™ pode guardar o iogurte em uma jarra de vidro ou mant√™-lo no recipiente original. Um conjunto de informa√ß√£o √© armazenada em um arquivo que pode ter v√°rios formatos ou extens√µes. A extens√£o do arquivo corresponde ao sufixo ap√≥s o ponto no nome do arquivo e indica como os dados est√£o organizados internamente e quais programas sabem interpret√°-los corretamente. Do ponto de vista conceitual, a extens√£o n√£o ‚Äúmuda‚Äù o dado em si, mas define a estrutura l√≥gica usada para representar a informa√ß√£o. O mesmo conjunto de informa√ß√µes pode ser salvo em formatos diferentes, dependendo do objetivo (leitura humana, processamento autom√°tico, troca entre sistemas etc.).\nUm formato muito comum em an√°lise de dados √© o CSV (.csv, Comma-Separated Values). Trata-se de um arquivo de texto em que os dados s√£o organizados em linhas e colunas, sendo as colunas separadas por um delimitador, geralmente uma v√≠rgula. Cada linha representa uma observa√ß√£o e a primeira linha costuma conter os nomes das vari√°veis. Arquivos CSV s√£o amplamente utilizados porque (i) s√£o simples e leg√≠veis; (ii) podem ser abertos em editores de texto, planilhas e softwares estat√≠sticos; e (iii) s√£o facilmente importados por linguagens como Python.\nOutro formato bastante utilizado √© o JSON (.json, JavaScript Object Notation). Embora tamb√©m seja um arquivo de texto, sua estrutura √© diferente. Em vez de linhas e colunas, os dados s√£o organizados como pares chave‚Äìvalor, de forma semelhante a um dicion√°rio, podendo conter listas e estruturas aninhadas. Esse formato √© muito usado para troca de dados entre sistemas e aplica√ß√µes, al√©m do uso para armazenamento de configura√ß√µes.\nOutras extens√µes comuns incluem:\n\n.txt: texto simples, sem estrutura fixa.\n.xlsx: arquivos de planilha do Microsoft Excel.\n.py: arquivos de c√≥digo Python.\n\n√â importante enfatizar que a extens√£o n√£o garante o conte√∫do do arquivo: um .csv mal formatado pode n√£o ser lido corretamente, e um arquivo .txt pode conter dados altamente estruturados. Ainda assim, seguir conven√ß√µes de extens√£o √© essencial para organiza√ß√£o de projetos, reprodutibilidade e interoperabilidade entre ferramentas. Considere a tabela de notas abaixo:\n\n\n\nnome\nnusp\ningresso\nmateria\nmedia\n\n\n\n\nJoao\n12345678\n2026\nEAE1106\n8\n\n\nMiguel\n5253678\n2023\nEAE1106\n4\n\n\nAlice\n9743678\n2025\nEAE1106\n9\n\n\n\nO armazenamento desses dados em formato CSV e JSON √© feito da seguinte maneira:\n\nFormato CSV\nnome,nusp,ingresso,materia,media\nJoao,12345678,2026,EAE1106,8\nMiguel,52543678,2023,EAE1106,4\nAlice,9743678,2025,EAE1106,9\nFormato JSON\n[\n{\n   \"nome\": \"Joao\",\n   \"nusp\": 12345678,\n   \"ingresso\": 2026,\n   \"materia\": \"EAE1106\",\n   \"media\": 8\n},\n{\n   \"nome\": \"Miguel\",\n   \"nusp\": 52543678,\n   \"ingresso\": 2023,\n   \"materia\": \"EAE1106\",\n   \"media\": 4\n},\n{\n   \"nome\": \"Alice\",\n   \"nusp\": 9743678,\n   \"ingresso\": 2025,\n   \"materia\": \"EAE1106\",\n   \"media\": \"9\"\n}\n]\n\nMas qual a import√¢ncia disso tudo? Entender como os computadores armazenam n√∫meros e como arquivos e diret√≥rios s√£o organizados e acessados pelo sistema operacional ajuda a compreender limita√ß√µes e comportamentos observados na pr√°tica. Por exemplo, explica por que um sistema de 32 bits √© capaz de alocar apenas at√© 4 GB de mem√≥ria RAM ou por que arquivos com milh√µes de linhas podem ser dif√≠ceis de abrir ou processar em um computador local.\nTer um conhecimento m√≠nimo sobre o funcionamento do computador e sobre como os programas interagem com sua arquitetura permite entender o que ocorre ‚Äúpor tr√°s das cortinas‚Äù. Com isso, podemos usar o computador como uma ferramenta para resolver problemas ‚Äî e n√£o como um fim em si. Para chegar a esse ponto, precisamos de meios formais para nos comunicar com o sistema operacional e, posteriormente, expressar instru√ß√µes de forma l√≥gica e precisa.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#terminal",
    "href": "fundamentos.html#terminal",
    "title": "1¬† Como um computador funciona",
    "section": "1.4 Terminal",
    "text": "1.4 Terminal\nUm passo intermedi√°rio entre o funcionamento interno do computador e as linguagens de programa√ß√£o √© o terminal. O terminal √© uma interface textual que permite interagir diretamente com o sistema operacional por meio de comandos simples. Em vez de clicar em √≠cones ou navegar por menus gr√°ficos, o usu√°rio descreve explicitamente o que deseja que o computador fa√ßa.\nO uso do terminal torna vis√≠veis conceitos introduzidos na se√ß√£o anterior, como arquivos e diret√≥rios, al√©m de fornecer um primeiro contato com a l√≥gica de comandos que ser√° essencial ao longo do curso. A Figura Figura¬†1.3 ilustra o ambiente t√≠pico do terminal nos dois principais sistemas operacionais em uso atualmente.\n\n\n\n\n\n\n\n\nWindows\n\n\n\n\n\n\n\nMacOS\n\n\n\n\n\n\nFigura¬†1.3: Interface usual do terminal\n\n\n\nComandos b√°sicos no terminal (ou prompt de comando) do Windows incluem:\n\ndir: lista arquivos e diret√≥rios no ambiente atual\ncd: muda de diret√≥rio\nmkdir: cria um novo diret√≥rio\n\nNo exemplo do painel A da Figura Figura¬†1.3, cd \"C:\\projeto\" muda o ambiente atual do diret√≥rio C:\\Users\\user para C:\\projeto. Note, por√©m, que se a pasta projeto estiver em outra parti√ß√£o do seu armazenamento, √© preciso primeiro mudar para essa parti√ß√£o para depois utilizar o comando cd. A Figura Figura¬†1.4 ilustra esses dois casos.\n\n\n\n\n\n\n\n\nDiret√≥rio na mesma parti√ß√£o\n\n\n\n\n\n\n\nDiret√≥rio em outra parti√ß√£o\n\n\n\n\n\n\nFigura¬†1.4: Exemplo de uso do terminal para mudar o ambiente atual\n\n\n\nMesmo que voc√™ utilize interfaces gr√°ficas, compreender o terminal facilita o entendimento de como o computador est√° organizado e de como o sistema operacional executa tarefas b√°sicas. Ao longo do curso, o terminal ser√° utilizado principalmente para executar programas, navegar entre diret√≥rios e instalar novos pacotes e ferramentas.\nApesar de √∫til, o terminal ainda exige que as instru√ß√µes sejam dadas comando a comando, de forma relativamente limitada e pouco reutiliz√°vel. Se queremos resolver problemas mais gerais e automatizar tarefas de forma sistem√°tica, √© necess√°rio um n√≠vel adicional de abstra√ß√£o.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#linguagens-de-programa√ß√£o",
    "href": "fundamentos.html#linguagens-de-programa√ß√£o",
    "title": "1¬† Como um computador funciona",
    "section": "1.5 Linguagens de programa√ß√£o",
    "text": "1.5 Linguagens de programa√ß√£o\nPara atingir esse n√≠vel adicional de abstra√ß√£o, precisamos de um meio de comunicar instru√ß√µes ao computador de maneira precisa e sem ambiguidades. Esse meio s√£o as linguagens de programa√ß√£o, que definem regras formais para descrever opera√ß√µes, decis√µes e c√°lculos que o computador pode executar. Diferentemente das linguagens naturais, como o portugu√™s que eu e voc√™ falamos, as linguagens de programa√ß√£o s√£o linguagens formais, que foram criadas pelas pessoas para aplica√ß√µes espec√≠ficas. A nota√ß√£o usada pelos matem√°ticos √© uma linguagem formal adequada para representar rela√ß√µes entre n√∫meros e s√≠mbolos; qu√≠micos utilizam linguagens formais para representar a estrutura de mol√©culas. Utilizamos as linguagens de programa√ß√£o para nos comunicar de forma inequ√≠voca com os computadores.\n\n1.5.1 Sintaxe e sem√¢ntica\nToda linguagem de programa√ß√£o possui dois n√≠veis fundamentais: sintaxe e sem√¢ntica.\nA sintaxe refere-se √†s regras de escrita da linguagem. Ela define quais s√≠mbolos e quais sequ√™ncias de s√≠mbolos s√£o v√°lidas: onde usar par√™nteses, palavras-chave, operadores e a ordem correta dos elementos. Erros de sintaxe s√£o, em geral, f√°ceis de identificar porque a execu√ß√£o do programa √© interrompida e uma mensagem de erro √© apresentada. Exemplos comuns incluem esquecer um caractere obrigat√≥rio em determinada sequ√™ncia, utilizar par√™nteses, colchetes ou aspas sem o fechamento correspondente ou escrever palavras-chave de forma incorreta. Nesses casos, o computador n√£o consegue sequer interpretar a estrutura do c√≥digo, independentemente da inten√ß√£o do programador.\nPor outro lado, a sem√¢ntica refere-se ao significado das instru√ß√µes. Um c√≥digo pode estar sintaticamente correto, mas produzir resultados errados por n√£o representar corretamente a inten√ß√£o do programador. Erros sem√¢nticos s√£o mais sutis, pois o c√≥digo respeita todas as regras formais da linguagem e √© executado normalmente, mas o resultado obtido est√° incorreto. Por exemplo, um programa pode calcular uma m√©dia dividindo a soma dos valores pelo n√∫mero errado de observa√ß√µes ou usar uma vari√°vel diferente da pretendida em uma express√£o. Esses erros n√£o geram mensagens autom√°ticas do computador e s√≥ podem ser detectados pela an√°lise cr√≠tica dos resultados produzidos.\nEssa distin√ß√£o √© central em programa√ß√£o. O computador consegue verificar automaticamente erros de sintaxe, mas n√£o √© capaz de julgar se o significado do programa est√° correto do ponto de vista do problema que se deseja resolver.\n\n\n1.5.2 Diferen√ßas entre linguagens naturais e formais\nEmbora as linguagens formais e naturais tenham muitas caracter√≠sticas em comum ‚Äì s√≠mbolos, estrutura, sintaxe e sem√¢ntica ‚Äì h√° algumas diferen√ßas:\n\nAmbiguidade: as linguagens naturais s√£o cheias de ambiguidade e as pessoas lidam com isso usando pistas contextuais e outras informa√ß√µes. As linguagens formais s√£o criadas para ser quase ou completamente inequ√≠vocas, ou seja, qualquer afirma√ß√£o tem exatamente um significado, independentemente do contexto\nRedund√¢ncia: para compensar a ambiguidade e reduzir equ√≠vocos, as linguagens naturais usam muita redund√¢ncia. Por causa disso, muitas vezes s√£o verborr√°gicas. As linguagens formais s√£o menos redundantes e mais concisas.\nLiteralidade: as linguagens naturais s√£o cheias de express√µes e met√°foras. Se eu digo ‚Äúcaiu a ficha‚Äù, provavelmente n√£o h√° ficha nenhuma na hist√≥ria, nem nada que tenha ca√≠do (esta √© uma express√£o para dizer que algu√©m entendeu algo depois de certo per√≠odo de confus√£o). As linguagens formais t√™m significados exatamente iguais ao que expressam.\n\nComo todos n√≥s crescemos falando linguagens naturais, √†s vezes √© dif√≠cil se ajustar a linguagens formais. As linguagens formais s√£o mais densas que as naturais, ent√£o exigem mais tempo para a leitura. Al√©m disso, a estrutura √© importante, ent√£o nem sempre √© melhor ler de cima para baixo e da esquerda para a direita. Em vez disso, aprenda a analisar o programa primeiro, identificando os s√≠mbolos e interpretando a estrutura. E os detalhes fazem diferen√ßa. Pequenos erros em ortografia e pontua√ß√£o, que podem n√£o importar tanto nas linguagens naturais, podem fazer uma grande diferen√ßa em uma l√≠ngua formal.\n\n\n1.5.3 Alto n√≠vel X baixo n√≠vel\nAs linguagens de programa√ß√£o tamb√©m diferem quanto ao seu n√≠vel de abstra√ß√£o. Na ci√™ncia da computa√ß√£o, linguagens de programa√ß√£o de alto n√≠vel abstraem detalhes do funcionamento interno do computador, permitindo que o programador se concentre na l√≥gica do problema. S√£o linguagens mais pr√≥ximas das linguagens humanas e mais distantes das linguagens de m√°quina (e do sistema bin√°rio). Tais linguagens podem usar elementos de linguagem natural, serem mais f√°ceis de usar, ou podem ocultar totalmente √°reas significativas de sistemas de computa√ß√£o, como o gerenciamento de mem√≥ria. Isso torna o processo de desenvolvimento de um programa mais simples e eficiente. Python, R e Java s√£o alguns exemplos de linguagens de alto n√≠vel.\nPor outro lado, uma linguagem de baixo n√≠vel √© uma linguagem de programa√ß√£o que fornece pouca ou nenhuma abstra√ß√£o de conceitos de programa√ß√£o e est√° muito pr√≥xima de escrever instru√ß√µes de m√°quina reais. A palavra ‚Äúbaixo‚Äù refere-se √† pequena ou inexistente quantidade de abstra√ß√£o entre a linguagem e a linguagem de m√°quina; por causa disso, as linguagens de baixo n√≠vel s√£o √†s vezes descritas como pr√≥ximas do hardware. Programas escritos em linguagens de baixo n√≠vel tendem a ser relativamente n√£o port√°teis e dependentes do computador para o qual foram escritas. Assembly √© uma das linguagens de mais baixo n√≠vel √† disposi√ß√£o do programador.\nEm cursos como Economia e outras ci√™ncias aplicadas, linguagens de alto n√≠vel s√£o preferidas porque reduzem o custo cognitivo, o tempo necess√°rio para produzir c√≥digo e aumentam a produtividade.\n\n\n1.5.4 Linguagem Compilada X Interpretada\nOutra distin√ß√£o importante diz respeito √† forma como o c√≥digo √© executado. Em linguagens compiladas o c√≥digo √© traduzido integralmente para c√≥digo de m√°quina antes da execu√ß√£o. Elas tamb√©m d√£o ao desenvolvedor mais controle sobre os aspectos de hardware, como gerenciamento de mem√≥ria e uso da CPU. As linguagens compiladas precisam de uma etapa de ‚Äúconstru√ß√£o‚Äù ‚Äì elas precisam ser compiladas manualmente primeiro. Somente ap√≥s essa etapa que o c√≥digo pode rodar por completo. Linguagens como C e C++ seguem esse modelo.\nEm linguagens interpretadas, as instru√ß√µes n√£o s√£o executadas diretamente pela m√°quina de destino, mas lidas e executadas, linha por linha, por algum outro programa, um int√©rprete. Isso permite maior flexibilidade e facilita a experimenta√ß√£o, embora geralmente com menor desempenho em tempo de m√°quina. Python e R s√£o exemplos cl√°ssicos de linguagens interpretadas.\nEmbora usualmente mais lentas, essa simplicidade e flexibilidade em escrever c√≥digo torna linguagens interpretadas particularmente adequadas para aprendizado, an√°lise de dados e trabalho emp√≠rico. Lembre-se, no fim das contas, o tempo relevante n√£o √© apenas o tempo de m√°quina, mas o tempo que voc√™ leva para escrever e depurar c√≥digo.\n\n\n1.5.5 Paradigmas\nLinguagens de programa√ß√£o tamb√©m podem ser classificadas segundo o paradigma que adotam, isto √©, o estilo predominante de organiza√ß√£o do c√≥digo. Entre os principais paradigmas de programa√ß√£o podemos citar programa√ß√£o imperativa, procedural, funcional, declarativa e programa√ß√£o orientada a objetos. Na programa√ß√£o imperativa, por exemplo, o programador diz como, o qu√™ e em qual ordem exatamente um programa ou rotina deve realizar. √â neste paradigma que surgiram as famosas estruturas condicionais e atribui√ß√£o de valor √† vari√°veis. Por outro lado, na programa√ß√£o orientada a objetos o programa √© estruturado em objetos que combinam dados e comportamento. Mais detalhes sobre paradigmas de programa√ß√£o podem ser obtidos aqui.\nMuitas linguagens modernas, incluindo Python, s√£o multiparadigma, permitindo combinar diferentes estilos conforme o problema.\n\n\n1.5.6 Tipagem\nPor fim, as linguagens diferem quanto √† forma como tratam os tipos de dados. Em linguagens de tipagem est√°tica, o tipo de cada vari√°vel √© definido explicitamente no c√≥digo e verificado antes da execu√ß√£o. O Python utiliza tipagem din√¢mica, isso significa que o pr√≥prio interpretador do Python infere o tipo dos dados que uma vari√°vel recebe, sem a necessidade que o usu√°rio diga de que tipo determinada vari√°vel √©. Al√©m disso, o Python √© uma linguagem fortemente tipada, o que significa que o interpretador do Python avalia as express√µes por conta pr√≥pria e n√£o faz convers√µes autom√°ticas de valores entre tipos de dados n√£o compat√≠veis. Ao fazer opera√ß√µes com tipos incompat√≠veis, o Python n√£o converte automaticamente esses tipos pra voc√™, ele vai dar erro.\nTipagem din√¢mica reduz a quantidade de c√≥digo inicial e facilita experimenta√ß√£o, mas exige aten√ß√£o adicional para evitar erros l√≥gicos j√° que o usu√°rio n√£o define explicitamente o tipo do dado. No entanto, a tipagem forte reduz a chance de resultados inesperados por conta de tipos definidos ou convertidos de forma equivocada j√° que a linguagem n√£o tenta corrigir o erro por conta pr√≥pria.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#algoritmos",
    "href": "fundamentos.html#algoritmos",
    "title": "1¬† Como um computador funciona",
    "section": "1.6 Algoritmos",
    "text": "1.6 Algoritmos\nA resolu√ß√£o de problemas est√° no centro da Ci√™ncia da Computa√ß√£o. Um algoritmo √© um conjunto finito e bem definido de instru√ß√µes, organizadas passo a passo, para resolver um problema ou realizar uma tarefa. Considere um problema simples: encontrar um nome em uma lista telef√¥nica. Como poder√≠amos resolv√™-lo?\nUma abordagem seria percorrer a lista p√°gina por p√°gina, do in√≠cio ao fim, at√© localizar o nome desejado. Outra possibilidade seria examinar duas p√°ginas por vez, tentando acelerar o processo. Uma estrat√©gia ainda mais eficiente seria abrir a lista aproximadamente no meio e perguntar: ‚ÄúO nome que procuro est√° antes ou depois desta p√°gina?‚Äù. A partir dessa resposta, descarta-se metade da lista e repete-se o procedimento na parte restante, reduzindo o problema pela metade a cada etapa.\nCada uma dessas estrat√©gias constitui um algoritmo - isto √©, uma sequ√™ncia organizada de instru√ß√µes para alcan√ßar um objetivo. Programadores transformam esse tipo de racioc√≠nio em c√≥digo, permitindo que o computador execute o algoritmo de forma autom√°tica e precisa.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#pseudoc√≥digo",
    "href": "fundamentos.html#pseudoc√≥digo",
    "title": "1¬† Como um computador funciona",
    "section": "1.7 Pseudoc√≥digo",
    "text": "1.7 Pseudoc√≥digo\nO pseudoc√≥digo √© uma forma de descrever algoritmos utilizando uma linguagem pr√≥xima da linguagem natural, mas estruturada de maneira semelhante a um programa de computador. Ele n√£o segue rigorosamente a sintaxe de uma linguagem espec√≠fica, mas organiza o racioc√≠nio l√≥gico de forma clara e sequencial.\nConsidere, por exemplo, o terceiro algoritmo utilizado para resolver o problema da lista telef√¥nica. Poder√≠amos descrev√™-lo em pseudoc√≥digo da seguinte maneira:\n1  Pegue a lista telef√¥nica\n2  Abra no meio da lista\n3  Observe a p√°gina\n4  Se a pessoa estiver na p√°gina\n5      Ligue para a pessoa\n6  Sen√£o, se a pessoa estiver antes\n7      Abra no meio da metade esquerda\n8      Volte para a linha 3\n9  Sen√£o, se a pessoa estiver depois\n10     Abra no meio da metade direita\n11     Volte para a linha 3\n12 Sen√£o\n13     Pare\nO pseudoc√≥digo √© importante por pelo menos duas raz√µes. Primeiro, ele permite estruturar e testar a l√≥gica da solu√ß√£o antes de traduzi-la para uma linguagem formal. Segundo, ele facilita a comunica√ß√£o do racioc√≠nio para outras pessoas, mesmo que elas n√£o dominem uma linguagem de programa√ß√£o espec√≠fica.\nObserve algumas caracter√≠sticas desse exemplo:\n\nAlgumas linhas come√ßam com verbos como ‚Äúpegue‚Äù, ‚Äúabra‚Äù ou ‚Äúobserve‚Äù. Essas a√ß√µes correspondem, em programa√ß√£o, a fun√ß√µes ou procedimentos.\nH√° instru√ß√µes como ‚Äúse‚Äù e ‚Äúsen√£o‚Äù, que representam estruturas condicionais, isto √©, decis√µes baseadas em determinadas condi√ß√µes.\nCertas afirma√ß√µes podem ser avaliadas como verdadeiras ou falsas, como ‚Äúa pessoa est√° antes no livro‚Äù. Essas s√£o chamadas de express√µes booleanas.\nInstru√ß√µes como ‚Äúvolte para a linha 3‚Äù representam estruturas de repeti√ß√£o, conhecidas como loops (ou la√ßos).\n\nEsses elementos - fun√ß√µes, condicionais, express√µes booleanas e la√ßos de repeti√ß√£o - constituem os blocos fundamentais da programa√ß√£o. No contexto do Python, linguagem utilizada neste curso, aprenderemos a implementar cada um desses componentes de maneira formal e estruturada.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#conclus√£o",
    "href": "fundamentos.html#conclus√£o",
    "title": "1¬† Como um computador funciona",
    "section": "1.8 Conclus√£o",
    "text": "1.8 Conclus√£o\nNeste cap√≠tulo, foram apresentados os fundamentos b√°sicos sobre o funcionamento de um sistema computacional, incluindo arquitetura, mem√≥ria, organiza√ß√£o de arquivos, intera√ß√£o com o sistema operacional e o papel das linguagens de programa√ß√£o. Esses conceitos fornecem a base necess√°ria para compreender como o computador executa instru√ß√µes e por que certas limita√ß√µes surgem na pr√°tica.\nA partir daqui, o curso passa a utilizar Python como linguagem de trabalho. Python √© uma linguagem de alto n√≠vel, interpretada e multiparadigma que √© amplamente empregada em an√°lise de dados e pesquisa emp√≠rica em Economia, pois permite expressar solu√ß√µes de forma clara e concisa, al√©m de oferecer um amplo conjunto de bibliotecas cient√≠ficas. No pr√≥ximo cap√≠tulo, iniciaremos o trabalho pr√°tico: escrever c√≥digo em Python, executar programas, interpretar erros e manipular dados diretamente no computador.",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#exerc√≠cios",
    "href": "fundamentos.html#exerc√≠cios",
    "title": "1¬† Como um computador funciona",
    "section": "1.9 Exerc√≠cios",
    "text": "1.9 Exerc√≠cios\n\nUm arquivo de dados possui 10 milh√µes de linhas e 80 colunas, com todas as c√©lulas contendo valores num√©ricos. Suponha que cada valor num√©rico ocupe 8 bytes na mem√≥ria.\n\nFa√ßa uma estimativa aproximada da quantidade de mem√≥ria RAM (em GB) necess√°ria para carregar esse arquivo inteiro na mem√≥ria.\nExplique por que um computador com pouca mem√≥ria RAM pode ter dificuldade para trabalhar com esse arquivo, mesmo que o arquivo ‚Äúcaiba‚Äù no disco r√≠gido.\n\nSobre o sistema bin√°rio responda:\n\nConverta o n√∫mero decimal 13 para a representa√ß√£o bin√°ria.\nConverta o n√∫mero bin√°rio 101101 para decimal.\nArgumente, em poucas linhas, sobre a vantagem de computadores utilizarem o sistema bin√°rio em vez do sistema decimal.\n\nConsidere a seguinte estrutura de diret√≥rios:\nD:/home/usuario/projeto/\n‚îú‚îÄ‚îÄ dados/\n‚îÇ   ‚îî‚îÄ‚îÄ alunos.csv\n‚îÇ   ‚îî‚îÄ‚îÄ professores.csv\n‚îÇ   ‚îî‚îÄ‚îÄ materias.csv\n‚îú‚îÄ‚îÄ scripts/\n‚îÇ   ‚îî‚îÄ‚îÄ analise.py\n‚îÇ   ‚îî‚îÄ‚îÄ amostra_final.py\n‚îî‚îÄ‚îÄ resultados/\n   ‚îî‚îÄ‚îÄ figura.png\n   ‚îî‚îÄ‚îÄ tabela.csv\n\nEscreva o caminho absoluto para o acessar o arquivo materias.csv.\nSuponha que voc√™ esteja no diret√≥rio scripts. Escreva o caminho relativo para acessar materias.csv. Dica: a pasta dados e scripts est√£o no mesmo n√≠vel hier√°rquico.\n\nConsidere a matem√°tica como uma linguagem formal, com regras bem definidas de escrita (sintaxe) e de significado (sem√¢ntica). Suponha que o objetivo seja calcular as ra√≠zes de uma equa√ß√£o do segundo grau da forma \\(ax^2 + bx + c = 0\\). Para tal voc√™ utilizar√° a f√≥rmula de Bh√°skara.\n\nSuponha que voc√™ opte por programar essa f√≥rmula tal qual apresentada abaixo em uma determinada linguagem de programa√ß√£o. Qual seria a sa√≠da esperada? Discuta o resultado.\n\\[x = \\frac{-b \\ge \\sqrt{b^2 - 4ac}}{2a}\\]\nSuponha que voc√™ opte por programar essa f√≥rmula tal qual apresentada abaixo em uma determinada linguagem de programa√ß√£o. Qual seria a sa√≠da esperada? Discuta o resultado.\n\\[x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2}\\]",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  },
  {
    "objectID": "fundamentos.html#footnotes",
    "href": "fundamentos.html#footnotes",
    "title": "1¬† Como um computador funciona",
    "section": "",
    "text": "Para entender um pouco mais sobre a hist√≥ria do sistema bin√°rio acesse o link.‚Ü©Ô∏é\nSe desejar se aprofundar no tema, voc√™ pode consultar mais informa√ß√µes sobre o sistema UNICODE e sobre emojis.‚Ü©Ô∏é",
    "crumbs": [
      "Fundamentos de Computa√ß√£o",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Como um computador funciona</span>"
    ]
  }
]